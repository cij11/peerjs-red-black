/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../libs/constants.js":
/*!****************************!*\
  !*** ../libs/constants.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const CONSTANTS = {\n    SET_GLOBAL_MATCH_INFO: \"SET_GLOBAL_MATCH_INFO\",\n    SET_GLOBAL_ROUND_INFO: \"SET_GLOBAL_ROUND_INFO\",\n    SET_PLAYER_MATCH_INFO: \"SET_PLAYER_MATCH_INFO\",\n    SET_PLAYER_ROUND_INFO: \"SET_PLAYER_ROUND_INFO\",\n    SET_ALL_INFO: \"SET_ALL_INFO\",\n\n    MATCH_STATE_NOT_CONNECTED: \"MATCH_STATE_NOT_CONNECTED\",\n    MATCH_STATE_ALL_CONNECTED: \"MATCH_STATE_ALL_CONNECTED\",\n\n    ROUND_STATE_INITIAL_PLACEMENT: \"ROUND_STATE_INITIAL_PLACEMENT\",\n    ROUND_STATE_PLACING: \"ROUND_STATE_PLACING\",\n    ROUND_STATE_CHALLENGING: \"ROUND_STATE_CHALLENGING\",\n    ROUND_STATE_REVEALING: \"ROUND_STATE_REVEALING\",\n\n    ALL_ACTIVE: \"ALL_ACTIVE\",\n\n    PLAY_BLACK_CARD: \"PLAY_BLACK_CARD\",\n    PLAY_RED_CARD: \"PLAY_RED_CARD\",\n    CHALLENGE: \"CHALLENGE\",\n    PASS: \"PASS\",\n    REVEAL: \"REVEAL\",\n\n    REQUIRED_PLAYERS: 2\n}\n\nmodule.exports = CONSTANTS;\n\n//# sourceURL=webpack:///../libs/constants.js?");

/***/ }),

/***/ "../libs/infos.js":
/*!************************!*\
  !*** ../libs/infos.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CONSTANTS = __webpack_require__(/*! ./constants.js */ \"../libs/constants.js\");\n\nfunction GlobalMatchInfo() {\n    return {\n        matchState: CONSTANTS.MATCH_STATE_NOT_CONNECTED,\n    };\n}\n\nfunction GlobalRoundInfo() {\n    return {\n        roundState: CONSTANTS.ROUND_STATE_INITIAL_PLACEMENT,\n        activePlayer: CONSTANTS.ALL_ACTIVE,\n        hasPlayedFirstCard: [],\n        skipped: [],\n        stackSizeByPlayer: {},\n        currentChallengeBid: 0,\n        successfulReveals: 0\n    }\n\n}\n\nfunction PlayerMatchInfo() {\n    return{\n        totalRedCards: 3,\n        totalBlackCards: 1,\n        wins: 0,\n        peerId: 'not-set',\n    }\n}\n\nfunction PlayerRoundInfo() {\n    return {\n        handRedCards: 3,\n        handBlackCards: 1,\n        stack: [],\n        peerId: 'not-set',\n    }\n}\n\nmodule.exports = {\n    GlobalMatchInfo,\n    GlobalRoundInfo,\n    PlayerRoundInfo,\n    PlayerMatchInfo,\n}\n\n//# sourceURL=webpack:///../libs/infos.js?");

/***/ }),

/***/ "../libs/peer.js":
/*!***********************!*\
  !*** ../libs/peer.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;\nexports.RTCPeerConnection = window.RTCPeerConnection ||\n    window.mozRTCPeerConnection ||\n    window.webkitRTCPeerConnection;\nexports.RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar eventemitter3_1 = require(\"eventemitter3\");\nvar negotiator_1 = require(\"./negotiator\");\nvar reliable_1 = require(\"reliable\");\nfunction DataConnection(peer, provider, options) {\n    if (!(this instanceof DataConnection))\n        return new DataConnection(peer, provider, options);\n    eventemitter3_1.EventEmitter.call(this);\n    this.options = util_1.util.extend({\n        serialization: \"binary\",\n        reliable: false\n    }, options);\n    this.open = false;\n    this.type = \"data\";\n    this.peer = peer;\n    this.provider = provider;\n    this.id =\n        this.options.connectionId || DataConnection._idPrefix + util_1.util.randomToken();\n    this.label = this.options.label || this.id;\n    this.metadata = this.options.metadata;\n    this.serialization = this.options.serialization;\n    this.reliable = this.options.reliable;\n    this._buffer = [];\n    this._buffering = false;\n    this.bufferSize = 0;\n    this._chunkedData = {};\n    if (this.options._payload) {\n        this._peerBrowser = this.options._payload.browser;\n    }\n    negotiator_1.Negotiator.startConnection(this, this.options._payload || {\n        originator: true\n    });\n}\nexports.DataConnection = DataConnection;\nutil_1.util.inherits(DataConnection, eventemitter3_1.EventEmitter);\nDataConnection._idPrefix = \"dc_\";\nDataConnection.prototype.initialize = function (dc) {\n    this._dc = this.dataChannel = dc;\n    this._configureDataChannel();\n};\nDataConnection.prototype._configureDataChannel = function () {\n    var self = this;\n    if (util_1.util.supports.sctp) {\n        this._dc.binaryType = \"arraybuffer\";\n    }\n    this._dc.onopen = function () {\n        util_1.util.log(\"Data channel connection success\");\n        self.open = true;\n        self.emit(\"open\");\n    };\n    if (!util_1.util.supports.sctp && this.reliable) {\n        this._reliable = new reliable_1.Reliable(this._dc, util_1.util.debug);\n    }\n    if (this._reliable) {\n        this._reliable.onmessage = function (msg) {\n            self.emit(\"data\", msg);\n        };\n    }\n    else {\n        this._dc.onmessage = function (e) {\n            self._handleDataMessage(e);\n        };\n    }\n    this._dc.onclose = function (e) {\n        util_1.util.log(\"DataChannel closed for:\", self.peer);\n        self.close();\n    };\n};\nDataConnection.prototype._handleDataMessage = function (e) {\n    var self = this;\n    var data = e.data;\n    var datatype = data.constructor;\n    if (this.serialization === \"binary\" || this.serialization === \"binary-utf8\") {\n        if (datatype === Blob) {\n            util_1.util.blobToArrayBuffer(data, function (ab) {\n                data = util_1.util.unpack(ab);\n                self.emit(\"data\", data);\n            });\n            return;\n        }\n        else if (datatype === ArrayBuffer) {\n            data = util_1.util.unpack(data);\n        }\n        else if (datatype === String) {\n            var ab = util_1.util.binaryStringToArrayBuffer(data);\n            data = util_1.util.unpack(ab);\n        }\n    }\n    else if (this.serialization === \"json\") {\n        data = JSON.parse(data);\n    }\n    if (data.__peerData) {\n        var id = data.__peerData;\n        var chunkInfo = this._chunkedData[id] || {\n            data: [],\n            count: 0,\n            total: data.total\n        };\n        chunkInfo.data[data.n] = data.data;\n        chunkInfo.count += 1;\n        if (chunkInfo.total === chunkInfo.count) {\n            delete this._chunkedData[id];\n            data = new Blob(chunkInfo.data);\n            this._handleDataMessage({ data: data });\n        }\n        this._chunkedData[id] = chunkInfo;\n        return;\n    }\n    this.emit(\"data\", data);\n};\nDataConnection.prototype.close = function () {\n    if (!this.open) {\n        return;\n    }\n    this.open = false;\n    negotiator_1.Negotiator.cleanup(this);\n    this.emit(\"close\");\n};\nDataConnection.prototype.send = function (data, chunked) {\n    if (!this.open) {\n        this.emit(\"error\", new Error(\"Connection is not open. You should listen for the `open` event before sending messages.\"));\n        return;\n    }\n    if (this._reliable) {\n        this._reliable.send(data);\n        return;\n    }\n    var self = this;\n    if (this.serialization === \"json\") {\n        this._bufferedSend(JSON.stringify(data));\n    }\n    else if (this.serialization === \"binary\" ||\n        this.serialization === \"binary-utf8\") {\n        var blob = util_1.util.pack(data);\n        var needsChunking = util_1.util.chunkedBrowsers[this._peerBrowser] ||\n            util_1.util.chunkedBrowsers[util_1.util.browser];\n        if (needsChunking && !chunked && blob.size > util_1.util.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        if (!util_1.util.supports.sctp) {\n            util_1.util.blobToBinaryString(blob, function (str) {\n                self._bufferedSend(str);\n            });\n        }\n        else if (!util_1.util.supports.binaryBlob) {\n            util_1.util.blobToArrayBuffer(blob, function (ab) {\n                self._bufferedSend(ab);\n            });\n        }\n        else {\n            this._bufferedSend(blob);\n        }\n    }\n    else {\n        this._bufferedSend(data);\n    }\n};\nDataConnection.prototype._bufferedSend = function (msg) {\n    if (this._buffering || !this._trySend(msg)) {\n        this._buffer.push(msg);\n        this.bufferSize = this._buffer.length;\n    }\n};\nDataConnection.prototype._trySend = function (msg) {\n    try {\n        this._dc.send(msg);\n    }\n    catch (e) {\n        this._buffering = true;\n        var self = this;\n        setTimeout(function () {\n            self._buffering = false;\n            self._tryBuffer();\n        }, 100);\n        return false;\n    }\n    return true;\n};\nDataConnection.prototype._tryBuffer = function () {\n    if (this._buffer.length === 0) {\n        return;\n    }\n    var msg = this._buffer[0];\n    if (this._trySend(msg)) {\n        this._buffer.shift();\n        this.bufferSize = this._buffer.length;\n        this._tryBuffer();\n    }\n};\nDataConnection.prototype._sendChunks = function (blob) {\n    var blobs = util_1.util.chunk(blob);\n    for (var i = 0, ii = blobs.length; i < ii; i += 1) {\n        var blob = blobs[i];\n        this.send(blob, true);\n    }\n};\nDataConnection.prototype.handleMessage = function (message) {\n    var payload = message.payload;\n    switch (message.type) {\n        case \"ANSWER\":\n            this._peerBrowser = payload.browser;\n            negotiator_1.Negotiator.handleSDP(message.type, this, payload.sdp);\n            break;\n        case \"CANDIDATE\":\n            negotiator_1.Negotiator.handleCandidate(this, payload.candidate);\n            break;\n        default:\n            util_1.util.warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n            break;\n    }\n};\n\n},{\"./negotiator\":5,\"./util\":8,\"eventemitter3\":9,\"reliable\":12}],3:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar adapter_1 = require(\"./adapter\");\nvar socket_1 = require(\"./socket\");\nvar mediaconnection_1 = require(\"./mediaconnection\");\nvar dataconnection_1 = require(\"./dataconnection\");\nvar peer_1 = require(\"./peer\");\nvar negotiator_1 = require(\"./negotiator\");\nvar js_binarypack_1 = __importDefault(require(\"js-binarypack\"));\nwindow.Socket = socket_1.Socket;\nwindow.MediaConnection = mediaconnection_1.MediaConnection;\nwindow.DataConnection = dataconnection_1.DataConnection;\nwindow.Peer = peer_1.Peer;\nwindow.RTCPeerConnection = adapter_1.RTCPeerConnection;\nwindow.RTCSessionDescription = adapter_1.RTCSessionDescription;\nwindow.RTCIceCandidate = adapter_1.RTCIceCandidate;\nwindow.Negotiator = negotiator_1.Negotiator;\nwindow.util = util_1.util;\nwindow.BinaryPack = js_binarypack_1.default;\n\n},{\"./adapter\":1,\"./dataconnection\":2,\"./mediaconnection\":4,\"./negotiator\":5,\"./peer\":6,\"./socket\":7,\"./util\":8,\"js-binarypack\":10}],4:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar eventemitter3_1 = require(\"eventemitter3\");\nvar negotiator_1 = require(\"./negotiator\");\nfunction MediaConnection(peer, provider, options) {\n    if (!(this instanceof MediaConnection))\n        return new MediaConnection(peer, provider, options);\n    eventemitter3_1.EventEmitter.call(this);\n    this.options = util_1.util.extend({}, options);\n    this.open = false;\n    this.type = \"media\";\n    this.peer = peer;\n    this.provider = provider;\n    this.metadata = this.options.metadata;\n    this.localStream = this.options._stream;\n    this.id =\n        this.options.connectionId || MediaConnection._idPrefix + util_1.util.randomToken();\n    if (this.localStream) {\n        negotiator_1.Negotiator.startConnection(this, {\n            _stream: this.localStream,\n            originator: true\n        });\n    }\n}\nexports.MediaConnection = MediaConnection;\nutil_1.util.inherits(MediaConnection, eventemitter3_1.EventEmitter);\nMediaConnection._idPrefix = \"mc_\";\nMediaConnection.prototype.addStream = function (remoteStream) {\n    util_1.util.log(\"Receiving stream\", remoteStream);\n    this.remoteStream = remoteStream;\n    this.emit(\"stream\", remoteStream);\n};\nMediaConnection.prototype.handleMessage = function (message) {\n    var payload = message.payload;\n    switch (message.type) {\n        case \"ANSWER\":\n            negotiator_1.Negotiator.handleSDP(message.type, this, payload.sdp);\n            this.open = true;\n            break;\n        case \"CANDIDATE\":\n            negotiator_1.Negotiator.handleCandidate(this, payload.candidate);\n            break;\n        default:\n            util_1.util.warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n            break;\n    }\n};\nMediaConnection.prototype.answer = function (stream) {\n    if (this.localStream) {\n        util_1.util.warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");\n        return;\n    }\n    this.options._payload._stream = stream;\n    this.localStream = stream;\n    negotiator_1.Negotiator.startConnection(this, this.options._payload);\n    var messages = this.provider._getMessages(this.id);\n    for (var i = 0, ii = messages.length; i < ii; i += 1) {\n        this.handleMessage(messages[i]);\n    }\n    this.open = true;\n};\nMediaConnection.prototype.close = function () {\n    if (!this.open) {\n        return;\n    }\n    this.open = false;\n    negotiator_1.Negotiator.cleanup(this);\n    this.emit(\"close\");\n};\n\n},{\"./negotiator\":5,\"./util\":8,\"eventemitter3\":9}],5:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar adapter_1 = require(\"./adapter\");\nexports.Negotiator = {\n    pcs: {\n        data: {},\n        media: {}\n    },\n    queue: []\n};\nexports.Negotiator._idPrefix = \"pc_\";\nexports.Negotiator.startConnection = function (connection, options) {\n    var pc = exports.Negotiator._getPeerConnection(connection, options);\n    connection.pc = connection.peerConnection = pc;\n    if (connection.type === \"media\" && options._stream) {\n        pc.addStream(options._stream);\n    }\n    if (options.originator) {\n        if (connection.type === \"data\") {\n            var config = {};\n            if (!util_1.util.supports.sctp) {\n                config = { reliable: options.reliable };\n            }\n            var dc = pc.createDataChannel(connection.label, config);\n            connection.initialize(dc);\n        }\n        exports.Negotiator._makeOffer(connection);\n    }\n    else {\n        exports.Negotiator.handleSDP(\"OFFER\", connection, options.sdp);\n    }\n};\nexports.Negotiator._getPeerConnection = function (connection, options) {\n    if (!exports.Negotiator.pcs[connection.type]) {\n        util_1.util.error(connection.type +\n            \" is not a valid connection type. Maybe you overrode the `type` property somewhere.\");\n    }\n    if (!exports.Negotiator.pcs[connection.type][connection.peer]) {\n        exports.Negotiator.pcs[connection.type][connection.peer] = {};\n    }\n    var peerConnections = exports.Negotiator.pcs[connection.type][connection.peer];\n    var pc;\n    if (options.pc) {\n        pc = exports.Negotiator.pcs[connection.type][connection.peer][options.pc];\n    }\n    if (!pc || pc.signalingState !== \"stable\") {\n        pc = exports.Negotiator._startPeerConnection(connection);\n    }\n    return pc;\n};\nexports.Negotiator._startPeerConnection = function (connection) {\n    util_1.util.log(\"Creating RTCPeerConnection.\");\n    var id = exports.Negotiator._idPrefix + util_1.util.randomToken();\n    var optional = {};\n    if (connection.type === \"data\" && !util_1.util.supports.sctp) {\n        optional = { optional: [{ RtpDataChannels: true }] };\n    }\n    else if (connection.type === \"media\") {\n        optional = { optional: [{ DtlsSrtpKeyAgreement: true }] };\n    }\n    var pc = new adapter_1.RTCPeerConnection(connection.provider.options.config, optional);\n    exports.Negotiator.pcs[connection.type][connection.peer][id] = pc;\n    exports.Negotiator._setupListeners(connection, pc, id);\n    return pc;\n};\nexports.Negotiator._setupListeners = function (connection, pc, pc_id) {\n    var peerId = connection.peer;\n    var connectionId = connection.id;\n    var provider = connection.provider;\n    util_1.util.log(\"Listening for ICE candidates.\");\n    pc.onicecandidate = function (evt) {\n        if (evt.candidate) {\n            util_1.util.log(\"Received ICE candidates for:\", connection.peer);\n            provider.socket.send({\n                type: \"CANDIDATE\",\n                payload: {\n                    candidate: evt.candidate,\n                    type: connection.type,\n                    connectionId: connection.id\n                },\n                dst: peerId\n            });\n        }\n    };\n    pc.oniceconnectionstatechange = function () {\n        switch (pc.iceConnectionState) {\n            case \"failed\":\n                util_1.util.log(\"iceConnectionState is disconnected, closing connections to \" + peerId);\n                connection.emit(\"error\", new Error(\"Negotiation of connection to \" + peerId + \" failed.\"));\n                connection.close();\n                break;\n            case \"disconnected\":\n                util_1.util.log(\"iceConnectionState is disconnected, closing connections to \" + peerId);\n                connection.close();\n                break;\n            case \"completed\":\n                pc.onicecandidate = util_1.util.noop;\n                break;\n        }\n    };\n    pc.onicechange = pc.oniceconnectionstatechange;\n    util_1.util.log(\"Listening for data channel\");\n    pc.ondatachannel = function (evt) {\n        util_1.util.log(\"Received data channel\");\n        var dc = evt.channel;\n        var connection = provider.getConnection(peerId, connectionId);\n        connection.initialize(dc);\n    };\n    util_1.util.log(\"Listening for remote stream\");\n    pc.ontrack = function (evt) {\n        util_1.util.log(\"Received remote stream\");\n        var stream = evt.streams[0];\n        var connection = provider.getConnection(peerId, connectionId);\n        if (connection.type === \"media\") {\n            connection.addStream(stream);\n        }\n    };\n};\nexports.Negotiator.cleanup = function (connection) {\n    util_1.util.log(\"Cleaning up PeerConnection to \" + connection.peer);\n    var pc = connection.pc;\n    if (!!pc &&\n        ((pc.readyState && pc.readyState !== \"closed\") ||\n            pc.signalingState !== \"closed\")) {\n        pc.close();\n        connection.pc = null;\n    }\n};\nexports.Negotiator._makeOffer = function (connection) {\n    var pc = connection.pc;\n    pc.createOffer(function (offer) {\n        util_1.util.log(\"Created offer.\");\n        if (!util_1.util.supports.sctp &&\n            connection.type === \"data\" &&\n            connection.reliable) {\n            offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);\n        }\n        pc.setLocalDescription(offer, function () {\n            util_1.util.log(\"Set localDescription: offer\", \"for:\", connection.peer);\n            connection.provider.socket.send({\n                type: \"OFFER\",\n                payload: {\n                    sdp: offer,\n                    type: connection.type,\n                    label: connection.label,\n                    connectionId: connection.id,\n                    reliable: connection.reliable,\n                    serialization: connection.serialization,\n                    metadata: connection.metadata,\n                    browser: util_1.util.browser\n                },\n                dst: connection.peer\n            });\n        }, function (err) {\n            if (err !=\n                \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                connection.provider.emitError(\"webrtc\", err);\n                util_1.util.log(\"Failed to setLocalDescription, \", err);\n            }\n        });\n    }, function (err) {\n        connection.provider.emitError(\"webrtc\", err);\n        util_1.util.log(\"Failed to createOffer, \", err);\n    }, connection.options.constraints);\n};\nexports.Negotiator._makeAnswer = function (connection) {\n    var pc = connection.pc;\n    pc.createAnswer(function (answer) {\n        util_1.util.log(\"Created answer.\");\n        if (!util_1.util.supports.sctp &&\n            connection.type === \"data\" &&\n            connection.reliable) {\n            answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);\n        }\n        pc.setLocalDescription(answer, function () {\n            util_1.util.log(\"Set localDescription: answer\", \"for:\", connection.peer);\n            connection.provider.socket.send({\n                type: \"ANSWER\",\n                payload: {\n                    sdp: answer,\n                    type: connection.type,\n                    connectionId: connection.id,\n                    browser: util_1.util.browser\n                },\n                dst: connection.peer\n            });\n        }, function (err) {\n            connection.provider.emitError(\"webrtc\", err);\n            util_1.util.log(\"Failed to setLocalDescription, \", err);\n        });\n    }, function (err) {\n        connection.provider.emitError(\"webrtc\", err);\n        util_1.util.log(\"Failed to create answer, \", err);\n    });\n};\nexports.Negotiator.handleSDP = function (type, connection, sdp) {\n    sdp = new adapter_1.RTCSessionDescription(sdp);\n    var pc = connection.pc;\n    util_1.util.log(\"Setting remote description\", sdp);\n    pc.setRemoteDescription(sdp, function () {\n        util_1.util.log(\"Set remoteDescription:\", type, \"for:\", connection.peer);\n        if (type === \"OFFER\") {\n            exports.Negotiator._makeAnswer(connection);\n        }\n    }, function (err) {\n        connection.provider.emitError(\"webrtc\", err);\n        util_1.util.log(\"Failed to setRemoteDescription, \", err);\n    });\n};\nexports.Negotiator.handleCandidate = function (connection, ice) {\n    var candidate = ice.candidate;\n    var sdpMLineIndex = ice.sdpMLineIndex;\n    connection.pc.addIceCandidate(new adapter_1.RTCIceCandidate({\n        sdpMLineIndex: sdpMLineIndex,\n        candidate: candidate\n    }));\n    util_1.util.log(\"Added ICE candidate for:\", connection.peer);\n};\n\n},{\"./adapter\":1,\"./util\":8}],6:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar eventemitter3_1 = require(\"eventemitter3\");\nvar socket_1 = require(\"./socket\");\nvar mediaconnection_1 = require(\"./mediaconnection\");\nvar dataconnection_1 = require(\"./dataconnection\");\nfunction Peer(id, options) {\n    if (!(this instanceof Peer))\n        return new Peer(id, options);\n    eventemitter3_1.EventEmitter.call(this);\n    if (id && id.constructor == Object) {\n        options = id;\n        id = undefined;\n    }\n    else if (id) {\n        id = id.toString();\n    }\n    options = util_1.util.extend({\n        debug: 0,\n        host: util_1.util.CLOUD_HOST,\n        port: util_1.util.CLOUD_PORT,\n        path: \"/\",\n        token: util_1.util.randomToken(),\n        config: util_1.util.defaultConfig\n    }, options);\n    options.key = \"peerjs\";\n    this.options = options;\n    if (options.host === \"/\") {\n        options.host = window.location.hostname;\n    }\n    if (options.path[0] !== \"/\") {\n        options.path = \"/\" + options.path;\n    }\n    if (options.path[options.path.length - 1] !== \"/\") {\n        options.path += \"/\";\n    }\n    if (options.secure === undefined && options.host !== util_1.util.CLOUD_HOST) {\n        options.secure = util_1.util.isSecure();\n    }\n    else if (options.host == util_1.util.CLOUD_HOST) {\n        options.secure = true;\n    }\n    if (options.logFunction) {\n        util_1.util.setLogFunction(options.logFunction);\n    }\n    util_1.util.setLogLevel(options.debug);\n    if (!util_1.util.supports.audioVideo && !util_1.util.supports.data) {\n        this._delayedAbort(\"browser-incompatible\", \"The current browser does not support WebRTC\");\n        return;\n    }\n    if (!util_1.util.validateId(id)) {\n        this._delayedAbort(\"invalid-id\", 'ID \"' + id + '\" is invalid');\n        return;\n    }\n    this.destroyed = false;\n    this.disconnected = false;\n    this.open = false;\n    this.connections = {};\n    this._lostMessages = {};\n    this._initializeServerConnection();\n    if (id) {\n        this._initialize(id);\n    }\n    else {\n        this._retrieveId();\n    }\n}\nexports.Peer = Peer;\nutil_1.util.inherits(Peer, eventemitter3_1.EventEmitter);\nPeer.prototype._initializeServerConnection = function () {\n    var self = this;\n    this.socket = new socket_1.Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key, this.options.wsport);\n    this.socket.on(\"message\", function (data) {\n        self._handleMessage(data);\n    });\n    this.socket.on(\"error\", function (error) {\n        self._abort(\"socket-error\", error);\n    });\n    this.socket.on(\"disconnected\", function () {\n        if (!self.disconnected) {\n            self.emitError(\"network\", \"Lost connection to server.\");\n            self.disconnect();\n        }\n    });\n    this.socket.on(\"close\", function () {\n        if (!self.disconnected) {\n            self._abort(\"socket-closed\", \"Underlying socket is already closed.\");\n        }\n    });\n};\nPeer.prototype._retrieveId = function (cb) {\n    var self = this;\n    var http = new XMLHttpRequest();\n    var protocol = this.options.secure ? \"https://\" : \"http://\";\n    var url = protocol +\n        this.options.host +\n        \":\" +\n        this.options.port +\n        this.options.path +\n        this.options.key +\n        \"/id\";\n    var queryString = \"?ts=\" + new Date().getTime() + \"\" + Math.random();\n    url += queryString;\n    http.open(\"get\", url, true);\n    http.onerror = function (e) {\n        util_1.util.error(\"Error retrieving ID\", e);\n        var pathError = \"\";\n        if (self.options.path === \"/\" && self.options.host !== util_1.util.CLOUD_HOST) {\n            pathError =\n                \" If you passed in a `path` to your self-hosted PeerServer, \" +\n                    \"you'll also need to pass in that same path when creating a new \" +\n                    \"Peer.\";\n        }\n        self._abort(\"server-error\", \"Could not get an ID from the server.\" + pathError);\n    };\n    http.onreadystatechange = function () {\n        if (http.readyState !== 4) {\n            return;\n        }\n        if (http.status !== 200) {\n            http.onerror();\n            return;\n        }\n        self._initialize(http.responseText);\n    };\n    http.send(null);\n};\nPeer.prototype._initialize = function (id) {\n    this.id = id;\n    this.socket.start(this.id, this.options.token);\n};\nPeer.prototype._handleMessage = function (message) {\n    var type = message.type;\n    var payload = message.payload;\n    var peer = message.src;\n    var connection;\n    switch (type) {\n        case \"OPEN\":\n            this.emit(\"open\", this.id);\n            this.open = true;\n            break;\n        case \"ERROR\":\n            this._abort(\"server-error\", payload.msg);\n            break;\n        case \"ID-TAKEN\":\n            this._abort(\"unavailable-id\", \"ID `\" + this.id + \"` is taken\");\n            break;\n        case \"INVALID-KEY\":\n            this._abort(\"invalid-key\", 'API KEY \"' + this.options.key + '\" is invalid');\n            break;\n        case \"LEAVE\":\n            util_1.util.log(\"Received leave message from\", peer);\n            this._cleanupPeer(peer);\n            break;\n        case \"EXPIRE\":\n            this.emitError(\"peer-unavailable\", \"Could not connect to peer \" + peer);\n            break;\n        case \"OFFER\":\n            var connectionId = payload.connectionId;\n            connection = this.getConnection(peer, connectionId);\n            if (connection) {\n                connection.close();\n                util_1.util.warn(\"Offer received for existing Connection ID:\", connectionId);\n            }\n            if (payload.type === \"media\") {\n                connection = new mediaconnection_1.MediaConnection(peer, this, {\n                    connectionId: connectionId,\n                    _payload: payload,\n                    metadata: payload.metadata\n                });\n                this._addConnection(peer, connection);\n                this.emit(\"call\", connection);\n            }\n            else if (payload.type === \"data\") {\n                connection = new dataconnection_1.DataConnection(peer, this, {\n                    connectionId: connectionId,\n                    _payload: payload,\n                    metadata: payload.metadata,\n                    label: payload.label,\n                    serialization: payload.serialization,\n                    reliable: payload.reliable\n                });\n                this._addConnection(peer, connection);\n                this.emit(\"connection\", connection);\n            }\n            else {\n                util_1.util.warn(\"Received malformed connection type:\", payload.type);\n                return;\n            }\n            var messages = this._getMessages(connectionId);\n            for (var i = 0, ii = messages.length; i < ii; i += 1) {\n                connection.handleMessage(messages[i]);\n            }\n            break;\n        default:\n            if (!payload) {\n                util_1.util.warn(\"You received a malformed message from \" + peer + \" of type \" + type);\n                return;\n            }\n            var id = payload.connectionId;\n            connection = this.getConnection(peer, id);\n            if (connection && connection.pc) {\n                connection.handleMessage(message);\n            }\n            else if (id) {\n                this._storeMessage(id, message);\n            }\n            else {\n                util_1.util.warn(\"You received an unrecognized message:\", message);\n            }\n            break;\n    }\n};\nPeer.prototype._storeMessage = function (connectionId, message) {\n    if (!this._lostMessages[connectionId]) {\n        this._lostMessages[connectionId] = [];\n    }\n    this._lostMessages[connectionId].push(message);\n};\nPeer.prototype._getMessages = function (connectionId) {\n    var messages = this._lostMessages[connectionId];\n    if (messages) {\n        delete this._lostMessages[connectionId];\n        return messages;\n    }\n    else {\n        return [];\n    }\n};\nPeer.prototype.connect = function (peer, options) {\n    if (this.disconnected) {\n        util_1.util.warn(\"You cannot connect to a new Peer because you called \" +\n            \".disconnect() on this Peer and ended your connection with the \" +\n            \"server. You can create a new Peer to reconnect, or call reconnect \" +\n            \"on this peer if you believe its ID to still be available.\");\n        this.emitError(\"disconnected\", \"Cannot connect to new Peer after disconnecting from server.\");\n        return;\n    }\n    var connection = new dataconnection_1.DataConnection(peer, this, options);\n    this._addConnection(peer, connection);\n    return connection;\n};\nPeer.prototype.call = function (peer, stream, options) {\n    if (this.disconnected) {\n        util_1.util.warn(\"You cannot connect to a new Peer because you called \" +\n            \".disconnect() on this Peer and ended your connection with the \" +\n            \"server. You can create a new Peer to reconnect.\");\n        this.emitError(\"disconnected\", \"Cannot connect to new Peer after disconnecting from server.\");\n        return;\n    }\n    if (!stream) {\n        util_1.util.error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\");\n        return;\n    }\n    options = options || {};\n    options._stream = stream;\n    var call = new mediaconnection_1.MediaConnection(peer, this, options);\n    this._addConnection(peer, call);\n    return call;\n};\nPeer.prototype._addConnection = function (peer, connection) {\n    if (!this.connections[peer]) {\n        this.connections[peer] = [];\n    }\n    this.connections[peer].push(connection);\n};\nPeer.prototype.getConnection = function (peer, id) {\n    var connections = this.connections[peer];\n    if (!connections) {\n        return null;\n    }\n    for (var i = 0, ii = connections.length; i < ii; i++) {\n        if (connections[i].id === id) {\n            return connections[i];\n        }\n    }\n    return null;\n};\nPeer.prototype._delayedAbort = function (type, message) {\n    var self = this;\n    util_1.util.setZeroTimeout(function () {\n        self._abort(type, message);\n    });\n};\nPeer.prototype._abort = function (type, message) {\n    util_1.util.error(\"Aborting!\");\n    if (!this._lastServerId) {\n        this.destroy();\n    }\n    else {\n        this.disconnect();\n    }\n    this.emitError(type, message);\n};\nPeer.prototype.emitError = function (type, err) {\n    util_1.util.error(\"Error:\", err);\n    if (typeof err === \"string\") {\n        err = new Error(err);\n    }\n    err.type = type;\n    this.emit(\"error\", err);\n};\nPeer.prototype.destroy = function () {\n    if (!this.destroyed) {\n        this._cleanup();\n        this.disconnect();\n        this.destroyed = true;\n    }\n};\nPeer.prototype._cleanup = function () {\n    if (this.connections) {\n        var peers = Object.keys(this.connections);\n        for (var i = 0, ii = peers.length; i < ii; i++) {\n            this._cleanupPeer(peers[i]);\n        }\n    }\n    this.emit(\"close\");\n};\nPeer.prototype._cleanupPeer = function (peer) {\n    var connections = this.connections[peer];\n    for (var j = 0, jj = connections.length; j < jj; j += 1) {\n        connections[j].close();\n    }\n};\nPeer.prototype.disconnect = function () {\n    var self = this;\n    util_1.util.setZeroTimeout(function () {\n        if (!self.disconnected) {\n            self.disconnected = true;\n            self.open = false;\n            if (self.socket) {\n                self.socket.close();\n            }\n            self.emit(\"disconnected\", self.id);\n            self._lastServerId = self.id;\n            self.id = null;\n        }\n    });\n};\nPeer.prototype.reconnect = function () {\n    if (this.disconnected && !this.destroyed) {\n        util_1.util.log(\"Attempting reconnection to server with ID \" + this._lastServerId);\n        this.disconnected = false;\n        this._initializeServerConnection();\n        this._initialize(this._lastServerId);\n    }\n    else if (this.destroyed) {\n        throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n    }\n    else if (!this.disconnected && !this.open) {\n        util_1.util.error(\"In a hurry? We're still trying to make the initial connection!\");\n    }\n    else {\n        throw new Error(\"Peer \" +\n            this.id +\n            \" cannot reconnect because it is not disconnected from the server!\");\n    }\n};\nPeer.prototype.listAllPeers = function (cb) {\n    cb = cb || function () { };\n    var self = this;\n    var http = new XMLHttpRequest();\n    var protocol = this.options.secure ? \"https://\" : \"http://\";\n    var url = protocol +\n        this.options.host +\n        \":\" +\n        this.options.port +\n        this.options.path +\n        this.options.key +\n        \"/peers\";\n    var queryString = \"?ts=\" + new Date().getTime() + \"\" + Math.random();\n    url += queryString;\n    http.open(\"get\", url, true);\n    http.onerror = function (e) {\n        self._abort(\"server-error\", \"Could not get peers from the server.\");\n        cb([]);\n    };\n    http.onreadystatechange = function () {\n        if (http.readyState !== 4) {\n            return;\n        }\n        if (http.status === 401) {\n            var helpfulError = \"\";\n            if (self.options.host !== util_1.util.CLOUD_HOST) {\n                helpfulError =\n                    \"It looks like you're using the cloud server. You can email \" +\n                        \"team@peerjs.com to enable peer listing for your API key.\";\n            }\n            else {\n                helpfulError =\n                    \"You need to enable `allow_discovery` on your self-hosted \" +\n                        \"PeerServer to use this feature.\";\n            }\n            cb([]);\n            throw new Error(\"It doesn't look like you have permission to list peers IDs. \" +\n                helpfulError);\n        }\n        else if (http.status !== 200) {\n            cb([]);\n        }\n        else {\n            cb(JSON.parse(http.responseText));\n        }\n    };\n    http.send(null);\n};\n\n},{\"./dataconnection\":2,\"./mediaconnection\":4,\"./socket\":7,\"./util\":8,\"eventemitter3\":9}],7:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar eventemitter3_1 = require(\"eventemitter3\");\nfunction Socket(secure, host, port, path, key, wsport) {\n    if (!(this instanceof Socket))\n        return new Socket(secure, host, port, path, key, wsport);\n    wsport = wsport || port;\n    eventemitter3_1.EventEmitter.call(this);\n    this.disconnected = false;\n    this._queue = [];\n    var httpProtocol = secure ? \"https://\" : \"http://\";\n    var wsProtocol = secure ? \"wss://\" : \"ws://\";\n    this._httpUrl = httpProtocol + host + \":\" + port + path + key;\n    this._wsUrl = wsProtocol + host + \":\" + wsport + path + \"peerjs?key=\" + key;\n}\nexports.Socket = Socket;\nutil_1.util.inherits(Socket, eventemitter3_1.EventEmitter);\nSocket.prototype.start = function (id, token) {\n    this.id = id;\n    this._httpUrl += \"/\" + id + \"/\" + token;\n    this._wsUrl += \"&id=\" + id + \"&token=\" + token;\n    this._startXhrStream();\n    this._startWebSocket();\n};\nSocket.prototype._startWebSocket = function (id) {\n    var self = this;\n    if (this._socket) {\n        return;\n    }\n    this._socket = new WebSocket(this._wsUrl);\n    this._socket.onmessage = function (event) {\n        try {\n            var data = JSON.parse(event.data);\n        }\n        catch (e) {\n            util_1.util.log(\"Invalid server message\", event.data);\n            return;\n        }\n        self.emit(\"message\", data);\n    };\n    this._socket.onclose = function (event) {\n        util_1.util.log(\"Socket closed.\");\n        self.disconnected = true;\n        self.emit(\"disconnected\");\n    };\n    this._socket.onopen = function () {\n        if (self._timeout) {\n            clearTimeout(self._timeout);\n            setTimeout(function () {\n                self._http.abort();\n                self._http = null;\n            }, 5000);\n        }\n        self._sendQueuedMessages();\n        util_1.util.log(\"Socket open\");\n    };\n};\nSocket.prototype._startXhrStream = function (n) {\n    try {\n        var self = this;\n        this._http = new XMLHttpRequest();\n        this._http._index = 1;\n        this._http._streamIndex = n || 0;\n        this._http.open(\"post\", this._httpUrl + \"/id?i=\" + this._http._streamIndex, true);\n        this._http.onerror = function () {\n            clearTimeout(self._timeout);\n            self.emit(\"disconnected\");\n        };\n        this._http.onreadystatechange = function () {\n            if (this.readyState == 2 && this.old) {\n                this.old.abort();\n                delete this.old;\n            }\n            else if (this.readyState > 2 &&\n                this.status === 200 &&\n                this.responseText) {\n                self._handleStream(this);\n            }\n        };\n        this._http.send(null);\n        this._setHTTPTimeout();\n    }\n    catch (e) {\n        util_1.util.log(\"XMLHttpRequest not available; defaulting to WebSockets\");\n    }\n};\nSocket.prototype._handleStream = function (http) {\n    var messages = http.responseText.split(\"\\n\");\n    if (http._buffer) {\n        while (http._buffer.length > 0) {\n            var index = http._buffer.shift();\n            var bufferedMessage = messages[index];\n            try {\n                bufferedMessage = JSON.parse(bufferedMessage);\n            }\n            catch (e) {\n                http._buffer.shift(index);\n                break;\n            }\n            this.emit(\"message\", bufferedMessage);\n        }\n    }\n    var message = messages[http._index];\n    if (message) {\n        http._index += 1;\n        if (http._index === messages.length) {\n            if (!http._buffer) {\n                http._buffer = [];\n            }\n            http._buffer.push(http._index - 1);\n        }\n        else {\n            try {\n                message = JSON.parse(message);\n            }\n            catch (e) {\n                util_1.util.log(\"Invalid server message\", message);\n                return;\n            }\n            this.emit(\"message\", message);\n        }\n    }\n};\nSocket.prototype._setHTTPTimeout = function () {\n    var self = this;\n    this._timeout = setTimeout(function () {\n        var old = self._http;\n        if (!self._wsOpen()) {\n            self._startXhrStream(old._streamIndex + 1);\n            self._http.old = old;\n        }\n        else {\n            old.abort();\n        }\n    }, 25000);\n};\nSocket.prototype._wsOpen = function () {\n    return this._socket && this._socket.readyState == 1;\n};\nSocket.prototype._sendQueuedMessages = function () {\n    for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n        this.send(this._queue[i]);\n    }\n};\nSocket.prototype.send = function (data) {\n    if (this.disconnected) {\n        return;\n    }\n    if (!this.id) {\n        this._queue.push(data);\n        return;\n    }\n    if (!data.type) {\n        this.emit(\"error\", \"Invalid message\");\n        return;\n    }\n    var message = JSON.stringify(data);\n    if (this._wsOpen()) {\n        this._socket.send(message);\n    }\n    else {\n        var http = new XMLHttpRequest();\n        var url = this._httpUrl + \"/\" + data.type.toLowerCase();\n        http.open(\"post\", url, true);\n        http.setRequestHeader(\"Content-Type\", \"application/json\");\n        http.send(message);\n    }\n};\nSocket.prototype.close = function () {\n    if (!this.disconnected && this._wsOpen()) {\n        this._socket.close();\n        this.disconnected = true;\n    }\n};\n\n},{\"./util\":8,\"eventemitter3\":9}],8:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar defaultConfig = { iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }] };\nvar dataCount = 1;\nvar js_binarypack_1 = __importDefault(require(\"js-binarypack\"));\nvar adapter_1 = require(\"./adapter\");\nexports.util = {\n    noop: function () { },\n    CLOUD_HOST: \"0.peerjs.com\",\n    CLOUD_PORT: 443,\n    chunkedBrowsers: { Chrome: 1 },\n    chunkedMTU: 16300,\n    logLevel: 0,\n    setLogLevel: function (level) {\n        var debugLevel = parseInt(level, 10);\n        if (!isNaN(parseInt(level, 10))) {\n            exports.util.logLevel = debugLevel;\n        }\n        else {\n            exports.util.logLevel = level ? 3 : 0;\n        }\n        exports.util.log = exports.util.warn = exports.util.error = exports.util.noop;\n        if (exports.util.logLevel > 0) {\n            exports.util.error = exports.util._printWith(\"ERROR\");\n        }\n        if (exports.util.logLevel > 1) {\n            exports.util.warn = exports.util._printWith(\"WARNING\");\n        }\n        if (exports.util.logLevel > 2) {\n            exports.util.log = exports.util._print;\n        }\n    },\n    setLogFunction: function (fn) {\n        if (fn.constructor !== Function) {\n            exports.util.warn(\"The log function you passed in is not a function. Defaulting to regular logs.\");\n        }\n        else {\n            exports.util._print = fn;\n        }\n    },\n    _printWith: function (prefix) {\n        return function () {\n            var copy = Array.prototype.slice.call(arguments);\n            copy.unshift(prefix);\n            exports.util._print.apply(exports.util, copy);\n        };\n    },\n    _print: function () {\n        var err = false;\n        var copy = Array.prototype.slice.call(arguments);\n        copy.unshift(\"PeerJS: \");\n        for (var i = 0, l = copy.length; i < l; i++) {\n            if (copy[i] instanceof Error) {\n                copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n                err = true;\n            }\n        }\n        err ? console.error.apply(console, copy) : console.log.apply(console, copy);\n    },\n    defaultConfig: defaultConfig,\n    browser: (function () {\n        if (window.mozRTCPeerConnection) {\n            return \"Firefox\";\n        }\n        else if (window.webkitRTCPeerConnection) {\n            return \"Chrome\";\n        }\n        else if (window.RTCPeerConnection) {\n            return \"Supported\";\n        }\n        else {\n            return \"Unsupported\";\n        }\n    })(),\n    supports: (function () {\n        if (typeof adapter_1.RTCPeerConnection === \"undefined\") {\n            return {};\n        }\n        var data = true;\n        var audioVideo = true;\n        var binaryBlob = false;\n        var sctp = false;\n        var onnegotiationneeded = !!window.webkitRTCPeerConnection;\n        var pc, dc;\n        try {\n            pc = new adapter_1.RTCPeerConnection(defaultConfig, {\n                optional: [{ RtpDataChannels: true }]\n            });\n        }\n        catch (e) {\n            data = false;\n            audioVideo = false;\n        }\n        if (data) {\n            try {\n                dc = pc.createDataChannel(\"_PEERJSTEST\");\n            }\n            catch (e) {\n                data = false;\n            }\n        }\n        if (data) {\n            try {\n                dc.binaryType = \"blob\";\n                binaryBlob = true;\n            }\n            catch (e) { }\n            var reliablePC = new adapter_1.RTCPeerConnection(defaultConfig, {});\n            try {\n                var reliableDC = reliablePC.createDataChannel(\"_PEERJSRELIABLETEST\", {});\n                sctp = reliableDC.reliable;\n            }\n            catch (e) { }\n            reliablePC.close();\n        }\n        if (audioVideo) {\n            audioVideo = !!pc.addStream;\n        }\n        if (pc) {\n            pc.close();\n        }\n        return {\n            audioVideo: audioVideo,\n            data: data,\n            binaryBlob: binaryBlob,\n            binary: sctp,\n            reliable: sctp,\n            sctp: sctp,\n            onnegotiationneeded: onnegotiationneeded\n        };\n    })(),\n    validateId: function (id) {\n        return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);\n    },\n    validateKey: function (key) {\n        return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);\n    },\n    debug: false,\n    inherits: function (ctor, superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n    },\n    extend: function (dest, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                dest[key] = source[key];\n            }\n        }\n        return dest;\n    },\n    pack: js_binarypack_1.default.pack,\n    unpack: js_binarypack_1.default.unpack,\n    log: function () {\n        if (exports.util.debug) {\n            var err = false;\n            var copy = Array.prototype.slice.call(arguments);\n            copy.unshift(\"PeerJS: \");\n            for (var i = 0, l = copy.length; i < l; i++) {\n                if (copy[i] instanceof Error) {\n                    copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n                    err = true;\n                }\n            }\n            err\n                ? console.error.apply(console, copy)\n                : console.log.apply(console, copy);\n        }\n    },\n    setZeroTimeout: (function (global) {\n        var timeouts = [];\n        var messageName = \"zero-timeout-message\";\n        function setZeroTimeoutPostMessage(fn) {\n            timeouts.push(fn);\n            global.postMessage(messageName, \"*\");\n        }\n        function handleMessage(event) {\n            if (event.source == global && event.data == messageName) {\n                if (event.stopPropagation) {\n                    event.stopPropagation();\n                }\n                if (timeouts.length) {\n                    timeouts.shift()();\n                }\n            }\n        }\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", handleMessage, true);\n        }\n        else if (global.attachEvent) {\n            global.attachEvent(\"onmessage\", handleMessage);\n        }\n        return setZeroTimeoutPostMessage;\n    })(window),\n    chunk: function (bl) {\n        var chunks = [];\n        var size = bl.size;\n        var index;\n        var start = (index = 0);\n        var total = Math.ceil(size / exports.util.chunkedMTU);\n        while (start < size) {\n            var end = Math.min(size, start + exports.util.chunkedMTU);\n            var b = bl.slice(start, end);\n            var chunk = {\n                __peerData: dataCount,\n                n: index,\n                data: b,\n                total: total\n            };\n            chunks.push(chunk);\n            start = end;\n            index += 1;\n        }\n        dataCount += 1;\n        return chunks;\n    },\n    blobToArrayBuffer: function (blob, cb) {\n        var fr = new FileReader();\n        fr.onload = function (evt) {\n            cb(evt.target.result);\n        };\n        fr.readAsArrayBuffer(blob);\n    },\n    blobToBinaryString: function (blob, cb) {\n        var fr = new FileReader();\n        fr.onload = function (evt) {\n            cb(evt.target.result);\n        };\n        fr.readAsBinaryString(blob);\n    },\n    binaryStringToArrayBuffer: function (binary) {\n        var byteArray = new Uint8Array(binary.length);\n        for (var i = 0; i < binary.length; i++) {\n            byteArray[i] = binary.charCodeAt(i) & 0xff;\n        }\n        return byteArray.buffer;\n    },\n    randomToken: function () {\n        return Math.random()\n            .toString(36)\n            .substr(2);\n    },\n    isSecure: function () {\n        return location.protocol === \"https:\";\n    }\n};\n\n},{\"./adapter\":1,\"js-binarypack\":10}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n},{}],10:[function(require,module,exports){\nvar BufferBuilder = require('./bufferbuilder').BufferBuilder;\r\nvar binaryFeatures = require('./bufferbuilder').binaryFeatures;\r\n\r\nvar BinaryPack = {\r\n  unpack: function(data){\r\n    var unpacker = new Unpacker(data);\r\n    return unpacker.unpack();\r\n  },\r\n  pack: function(data){\r\n    var packer = new Packer();\r\n    packer.pack(data);\r\n    var buffer = packer.getBuffer();\r\n    return buffer;\r\n  }\r\n};\r\n\r\nmodule.exports = BinaryPack;\r\n\r\nfunction Unpacker (data){\r\n  // Data is ArrayBuffer\r\n  this.index = 0;\r\n  this.dataBuffer = data;\r\n  this.dataView = new Uint8Array(this.dataBuffer);\r\n  this.length = this.dataBuffer.byteLength;\r\n}\r\n\r\nUnpacker.prototype.unpack = function(){\r\n  var type = this.unpack_uint8();\r\n  if (type < 0x80){\r\n    var positive_fixnum = type;\r\n    return positive_fixnum;\r\n  } else if ((type ^ 0xe0) < 0x20){\r\n    var negative_fixnum = (type ^ 0xe0) - 0x20;\r\n    return negative_fixnum;\r\n  }\r\n  var size;\r\n  if ((size = type ^ 0xa0) <= 0x0f){\r\n    return this.unpack_raw(size);\r\n  } else if ((size = type ^ 0xb0) <= 0x0f){\r\n    return this.unpack_string(size);\r\n  } else if ((size = type ^ 0x90) <= 0x0f){\r\n    return this.unpack_array(size);\r\n  } else if ((size = type ^ 0x80) <= 0x0f){\r\n    return this.unpack_map(size);\r\n  }\r\n  switch(type){\r\n    case 0xc0:\r\n      return null;\r\n    case 0xc1:\r\n      return undefined;\r\n    case 0xc2:\r\n      return false;\r\n    case 0xc3:\r\n      return true;\r\n    case 0xca:\r\n      return this.unpack_float();\r\n    case 0xcb:\r\n      return this.unpack_double();\r\n    case 0xcc:\r\n      return this.unpack_uint8();\r\n    case 0xcd:\r\n      return this.unpack_uint16();\r\n    case 0xce:\r\n      return this.unpack_uint32();\r\n    case 0xcf:\r\n      return this.unpack_uint64();\r\n    case 0xd0:\r\n      return this.unpack_int8();\r\n    case 0xd1:\r\n      return this.unpack_int16();\r\n    case 0xd2:\r\n      return this.unpack_int32();\r\n    case 0xd3:\r\n      return this.unpack_int64();\r\n    case 0xd4:\r\n      return undefined;\r\n    case 0xd5:\r\n      return undefined;\r\n    case 0xd6:\r\n      return undefined;\r\n    case 0xd7:\r\n      return undefined;\r\n    case 0xd8:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_string(size);\r\n    case 0xd9:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_string(size);\r\n    case 0xda:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_raw(size);\r\n    case 0xdb:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_raw(size);\r\n    case 0xdc:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_array(size);\r\n    case 0xdd:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_array(size);\r\n    case 0xde:\r\n      size = this.unpack_uint16();\r\n      return this.unpack_map(size);\r\n    case 0xdf:\r\n      size = this.unpack_uint32();\r\n      return this.unpack_map(size);\r\n  }\r\n}\r\n\r\nUnpacker.prototype.unpack_uint8 = function(){\r\n  var byte = this.dataView[this.index] & 0xff;\r\n  this.index++;\r\n  return byte;\r\n};\r\n\r\nUnpacker.prototype.unpack_uint16 = function(){\r\n  var bytes = this.read(2);\r\n  var uint16 =\r\n    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);\r\n  this.index += 2;\r\n  return uint16;\r\n}\r\n\r\nUnpacker.prototype.unpack_uint32 = function(){\r\n  var bytes = this.read(4);\r\n  var uint32 =\r\n     ((bytes[0]  * 256 +\r\n       bytes[1]) * 256 +\r\n       bytes[2]) * 256 +\r\n       bytes[3];\r\n  this.index += 4;\r\n  return uint32;\r\n}\r\n\r\nUnpacker.prototype.unpack_uint64 = function(){\r\n  var bytes = this.read(8);\r\n  var uint64 =\r\n   ((((((bytes[0]  * 256 +\r\n       bytes[1]) * 256 +\r\n       bytes[2]) * 256 +\r\n       bytes[3]) * 256 +\r\n       bytes[4]) * 256 +\r\n       bytes[5]) * 256 +\r\n       bytes[6]) * 256 +\r\n       bytes[7];\r\n  this.index += 8;\r\n  return uint64;\r\n}\r\n\r\n\r\nUnpacker.prototype.unpack_int8 = function(){\r\n  var uint8 = this.unpack_uint8();\r\n  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);\r\n};\r\n\r\nUnpacker.prototype.unpack_int16 = function(){\r\n  var uint16 = this.unpack_uint16();\r\n  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);\r\n}\r\n\r\nUnpacker.prototype.unpack_int32 = function(){\r\n  var uint32 = this.unpack_uint32();\r\n  return (uint32 < Math.pow(2, 31) ) ? uint32 :\r\n    uint32 - Math.pow(2, 32);\r\n}\r\n\r\nUnpacker.prototype.unpack_int64 = function(){\r\n  var uint64 = this.unpack_uint64();\r\n  return (uint64 < Math.pow(2, 63) ) ? uint64 :\r\n    uint64 - Math.pow(2, 64);\r\n}\r\n\r\nUnpacker.prototype.unpack_raw = function(size){\r\n  if ( this.length < this.index + size){\r\n    throw new Error('BinaryPackFailure: index is out of range'\r\n      + ' ' + this.index + ' ' + size + ' ' + this.length);\r\n  }\r\n  var buf = this.dataBuffer.slice(this.index, this.index + size);\r\n  this.index += size;\r\n\r\n    //buf = util.bufferToString(buf);\r\n\r\n  return buf;\r\n}\r\n\r\nUnpacker.prototype.unpack_string = function(size){\r\n  var bytes = this.read(size);\r\n  var i = 0, str = '', c, code;\r\n  while(i < size){\r\n    c = bytes[i];\r\n    if ( c < 128){\r\n      str += String.fromCharCode(c);\r\n      i++;\r\n    } else if ((c ^ 0xc0) < 32){\r\n      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);\r\n      str += String.fromCharCode(code);\r\n      i += 2;\r\n    } else {\r\n      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |\r\n        (bytes[i+2] & 63);\r\n      str += String.fromCharCode(code);\r\n      i += 3;\r\n    }\r\n  }\r\n  this.index += size;\r\n  return str;\r\n}\r\n\r\nUnpacker.prototype.unpack_array = function(size){\r\n  var objects = new Array(size);\r\n  for(var i = 0; i < size ; i++){\r\n    objects[i] = this.unpack();\r\n  }\r\n  return objects;\r\n}\r\n\r\nUnpacker.prototype.unpack_map = function(size){\r\n  var map = {};\r\n  for(var i = 0; i < size ; i++){\r\n    var key  = this.unpack();\r\n    var value = this.unpack();\r\n    map[key] = value;\r\n  }\r\n  return map;\r\n}\r\n\r\nUnpacker.prototype.unpack_float = function(){\r\n  var uint32 = this.unpack_uint32();\r\n  var sign = uint32 >> 31;\r\n  var exp  = ((uint32 >> 23) & 0xff) - 127;\r\n  var fraction = ( uint32 & 0x7fffff ) | 0x800000;\r\n  return (sign == 0 ? 1 : -1) *\r\n    fraction * Math.pow(2, exp - 23);\r\n}\r\n\r\nUnpacker.prototype.unpack_double = function(){\r\n  var h32 = this.unpack_uint32();\r\n  var l32 = this.unpack_uint32();\r\n  var sign = h32 >> 31;\r\n  var exp  = ((h32 >> 20) & 0x7ff) - 1023;\r\n  var hfrac = ( h32 & 0xfffff ) | 0x100000;\r\n  var frac = hfrac * Math.pow(2, exp - 20) +\r\n    l32   * Math.pow(2, exp - 52);\r\n  return (sign == 0 ? 1 : -1) * frac;\r\n}\r\n\r\nUnpacker.prototype.read = function(length){\r\n  var j = this.index;\r\n  if (j + length <= this.length) {\r\n    return this.dataView.subarray(j, j + length);\r\n  } else {\r\n    throw new Error('BinaryPackFailure: read index out of range');\r\n  }\r\n}\r\n\r\nfunction Packer(){\r\n  this.bufferBuilder = new BufferBuilder();\r\n}\r\n\r\nPacker.prototype.getBuffer = function(){\r\n  return this.bufferBuilder.getBuffer();\r\n}\r\n\r\nPacker.prototype.pack = function(value){\r\n  var type = typeof(value);\r\n  if (type == 'string'){\r\n    this.pack_string(value);\r\n  } else if (type == 'number'){\r\n    if (Math.floor(value) === value){\r\n      this.pack_integer(value);\r\n    } else{\r\n      this.pack_double(value);\r\n    }\r\n  } else if (type == 'boolean'){\r\n    if (value === true){\r\n      this.bufferBuilder.append(0xc3);\r\n    } else if (value === false){\r\n      this.bufferBuilder.append(0xc2);\r\n    }\r\n  } else if (type == 'undefined'){\r\n    this.bufferBuilder.append(0xc0);\r\n  } else if (type == 'object'){\r\n    if (value === null){\r\n      this.bufferBuilder.append(0xc0);\r\n    } else {\r\n      var constructor = value.constructor;\r\n      if (constructor == Array){\r\n        this.pack_array(value);\r\n      } else if (constructor == Blob || constructor == File) {\r\n        this.pack_bin(value);\r\n      } else if (constructor == ArrayBuffer) {\r\n        if(binaryFeatures.useArrayBufferView) {\r\n          this.pack_bin(new Uint8Array(value));\r\n        } else {\r\n          this.pack_bin(value);\r\n        }\r\n      } else if ('BYTES_PER_ELEMENT' in value){\r\n        if(binaryFeatures.useArrayBufferView) {\r\n          this.pack_bin(new Uint8Array(value.buffer));\r\n        } else {\r\n          this.pack_bin(value.buffer);\r\n        }\r\n      } else if (constructor == Object){\r\n        this.pack_object(value);\r\n      } else if (constructor == Date){\r\n        this.pack_string(value.toString());\r\n      } else if (typeof value.toBinaryPack == 'function'){\r\n        this.bufferBuilder.append(value.toBinaryPack());\r\n      } else {\r\n        throw new Error('Type \"' + constructor.toString() + '\" not yet supported');\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('Type \"' + type + '\" not yet supported');\r\n  }\r\n  this.bufferBuilder.flush();\r\n}\r\n\r\n\r\nPacker.prototype.pack_bin = function(blob){\r\n  var length = blob.length || blob.byteLength || blob.size;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0xa0 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xda) ;\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdb);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  this.bufferBuilder.append(blob);\r\n}\r\n\r\nPacker.prototype.pack_string = function(str){\r\n  var length = utf8Length(str);\r\n\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0xb0 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xd8) ;\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xd9);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  this.bufferBuilder.append(str);\r\n}\r\n\r\nPacker.prototype.pack_array = function(ary){\r\n  var length = ary.length;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0x90 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xdc)\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdd);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  for(var i = 0; i < length ; i++){\r\n    this.pack(ary[i]);\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_integer = function(num){\r\n  if ( -0x20 <= num && num <= 0x7f){\r\n    this.bufferBuilder.append(num & 0xff);\r\n  } else if (0x00 <= num && num <= 0xff){\r\n    this.bufferBuilder.append(0xcc);\r\n    this.pack_uint8(num);\r\n  } else if (-0x80 <= num && num <= 0x7f){\r\n    this.bufferBuilder.append(0xd0);\r\n    this.pack_int8(num);\r\n  } else if ( 0x0000 <= num && num <= 0xffff){\r\n    this.bufferBuilder.append(0xcd);\r\n    this.pack_uint16(num);\r\n  } else if (-0x8000 <= num && num <= 0x7fff){\r\n    this.bufferBuilder.append(0xd1);\r\n    this.pack_int16(num);\r\n  } else if ( 0x00000000 <= num && num <= 0xffffffff){\r\n    this.bufferBuilder.append(0xce);\r\n    this.pack_uint32(num);\r\n  } else if (-0x80000000 <= num && num <= 0x7fffffff){\r\n    this.bufferBuilder.append(0xd2);\r\n    this.pack_int32(num);\r\n  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){\r\n    this.bufferBuilder.append(0xd3);\r\n    this.pack_int64(num);\r\n  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){\r\n    this.bufferBuilder.append(0xcf);\r\n    this.pack_uint64(num);\r\n  } else{\r\n    throw new Error('Invalid integer');\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_double = function(num){\r\n  var sign = 0;\r\n  if (num < 0){\r\n    sign = 1;\r\n    num = -num;\r\n  }\r\n  var exp  = Math.floor(Math.log(num) / Math.LN2);\r\n  var frac0 = num / Math.pow(2, exp) - 1;\r\n  var frac1 = Math.floor(frac0 * Math.pow(2, 52));\r\n  var b32   = Math.pow(2, 32);\r\n  var h32 = (sign << 31) | ((exp+1023) << 20) |\r\n      (frac1 / b32) & 0x0fffff;\r\n  var l32 = frac1 % b32;\r\n  this.bufferBuilder.append(0xcb);\r\n  this.pack_int32(h32);\r\n  this.pack_int32(l32);\r\n}\r\n\r\nPacker.prototype.pack_object = function(obj){\r\n  var keys = Object.keys(obj);\r\n  var length = keys.length;\r\n  if (length <= 0x0f){\r\n    this.pack_uint8(0x80 + length);\r\n  } else if (length <= 0xffff){\r\n    this.bufferBuilder.append(0xde);\r\n    this.pack_uint16(length);\r\n  } else if (length <= 0xffffffff){\r\n    this.bufferBuilder.append(0xdf);\r\n    this.pack_uint32(length);\r\n  } else{\r\n    throw new Error('Invalid length');\r\n  }\r\n  for(var prop in obj){\r\n    if (obj.hasOwnProperty(prop)){\r\n      this.pack(prop);\r\n      this.pack(obj[prop]);\r\n    }\r\n  }\r\n}\r\n\r\nPacker.prototype.pack_uint8 = function(num){\r\n  this.bufferBuilder.append(num);\r\n}\r\n\r\nPacker.prototype.pack_uint16 = function(num){\r\n  this.bufferBuilder.append(num >> 8);\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_uint32 = function(num){\r\n  var n = num & 0xffffffff;\r\n  this.bufferBuilder.append((n & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((n & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_uint64 = function(num){\r\n  var high = num / Math.pow(2, 32);\r\n  var low  = num % Math.pow(2, 32);\r\n  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((high & 0x000000ff));\r\n  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((low  & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_int8 = function(num){\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_int16 = function(num){\r\n  this.bufferBuilder.append((num & 0xff00) >> 8);\r\n  this.bufferBuilder.append(num & 0xff);\r\n}\r\n\r\nPacker.prototype.pack_int32 = function(num){\r\n  this.bufferBuilder.append((num >>> 24) & 0xff);\r\n  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);\r\n  this.bufferBuilder.append((num & 0x000000ff));\r\n}\r\n\r\nPacker.prototype.pack_int64 = function(num){\r\n  var high = Math.floor(num / Math.pow(2, 32));\r\n  var low  = num % Math.pow(2, 32);\r\n  this.bufferBuilder.append((high & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((high & 0x000000ff));\r\n  this.bufferBuilder.append((low  & 0xff000000) >>> 24);\r\n  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);\r\n  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);\r\n  this.bufferBuilder.append((low  & 0x000000ff));\r\n}\r\n\r\nfunction _utf8Replace(m){\r\n  var code = m.charCodeAt(0);\r\n\r\n  if(code <= 0x7ff) return '00';\r\n  if(code <= 0xffff) return '000';\r\n  if(code <= 0x1fffff) return '0000';\r\n  if(code <= 0x3ffffff) return '00000';\r\n  return '000000';\r\n}\r\n\r\nfunction utf8Length(str){\r\n  if (str.length > 600) {\r\n    // Blob method faster for large strings\r\n    return (new Blob([str])).size;\r\n  } else {\r\n    return str.replace(/[^\\u0000-\\u007F]/g, _utf8Replace).length;\r\n  }\r\n}\r\n\n},{\"./bufferbuilder\":11}],11:[function(require,module,exports){\nvar binaryFeatures = {};\r\nbinaryFeatures.useBlobBuilder = (function(){\r\n  try {\r\n    new Blob([]);\r\n    return false;\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n})();\r\n\r\nbinaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){\r\n  try {\r\n    return (new Blob([new Uint8Array([])])).size === 0;\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n})();\r\n\r\nmodule.exports.binaryFeatures = binaryFeatures;\r\nvar BlobBuilder = module.exports.BlobBuilder;\r\nif (typeof window != 'undefined') {\r\n  BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder ||\r\n    window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;\r\n}\r\n\r\nfunction BufferBuilder(){\r\n  this._pieces = [];\r\n  this._parts = [];\r\n}\r\n\r\nBufferBuilder.prototype.append = function(data) {\r\n  if(typeof data === 'number') {\r\n    this._pieces.push(data);\r\n  } else {\r\n    this.flush();\r\n    this._parts.push(data);\r\n  }\r\n};\r\n\r\nBufferBuilder.prototype.flush = function() {\r\n  if (this._pieces.length > 0) {\r\n    var buf = new Uint8Array(this._pieces);\r\n    if(!binaryFeatures.useArrayBufferView) {\r\n      buf = buf.buffer;\r\n    }\r\n    this._parts.push(buf);\r\n    this._pieces = [];\r\n  }\r\n};\r\n\r\nBufferBuilder.prototype.getBuffer = function() {\r\n  this.flush();\r\n  if(binaryFeatures.useBlobBuilder) {\r\n    var builder = new BlobBuilder();\r\n    for(var i = 0, ii = this._parts.length; i < ii; i++) {\r\n      builder.append(this._parts[i]);\r\n    }\r\n    return builder.getBlob();\r\n  } else {\r\n    return new Blob(this._parts);\r\n  }\r\n};\r\n\r\nmodule.exports.BufferBuilder = BufferBuilder;\r\n\n},{}],12:[function(require,module,exports){\nvar util = require('./util');\n\n/**\n * Reliable transfer for Chrome Canary DataChannel impl.\n * Author: @michellebu\n */\nfunction Reliable(dc, debug) {\n  if (!(this instanceof Reliable)) return new Reliable(dc);\n  this._dc = dc;\n\n  util.debug = debug;\n\n  // Messages sent/received so far.\n  // id: { ack: n, chunks: [...] }\n  this._outgoing = {};\n  // id: { ack: ['ack', id, n], chunks: [...] }\n  this._incoming = {};\n  this._received = {};\n\n  // Window size.\n  this._window = 1000;\n  // MTU.\n  this._mtu = 500;\n  // Interval for setInterval. In ms.\n  this._interval = 0;\n\n  // Messages sent.\n  this._count = 0;\n\n  // Outgoing message queue.\n  this._queue = [];\n\n  this._setupDC();\n};\n\n// Send a message reliably.\nReliable.prototype.send = function(msg) {\n  // Determine if chunking is necessary.\n  var bl = util.pack(msg);\n  if (bl.size < this._mtu) {\n    this._handleSend(['no', bl]);\n    return;\n  }\n\n  this._outgoing[this._count] = {\n    ack: 0,\n    chunks: this._chunk(bl)\n  };\n\n  if (util.debug) {\n    this._outgoing[this._count].timer = new Date();\n  }\n\n  // Send prelim window.\n  this._sendWindowedChunks(this._count);\n  this._count += 1;\n};\n\n// Set up interval for processing queue.\nReliable.prototype._setupInterval = function() {\n  // TODO: fail gracefully.\n\n  var self = this;\n  this._timeout = setInterval(function() {\n    // FIXME: String stuff makes things terribly async.\n    var msg = self._queue.shift();\n    if (msg._multiple) {\n      for (var i = 0, ii = msg.length; i < ii; i += 1) {\n        self._intervalSend(msg[i]);\n      }\n    } else {\n      self._intervalSend(msg);\n    }\n  }, this._interval);\n};\n\nReliable.prototype._intervalSend = function(msg) {\n  var self = this;\n  msg = util.pack(msg);\n  util.blobToBinaryString(msg, function(str) {\n    self._dc.send(str);\n  });\n  if (self._queue.length === 0) {\n    clearTimeout(self._timeout);\n    self._timeout = null;\n    //self._processAcks();\n  }\n};\n\n// Go through ACKs to send missing pieces.\nReliable.prototype._processAcks = function() {\n  for (var id in this._outgoing) {\n    if (this._outgoing.hasOwnProperty(id)) {\n      this._sendWindowedChunks(id);\n    }\n  }\n};\n\n// Handle sending a message.\n// FIXME: Don't wait for interval time for all messages...\nReliable.prototype._handleSend = function(msg) {\n  var push = true;\n  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {\n    var item = this._queue[i];\n    if (item === msg) {\n      push = false;\n    } else if (item._multiple && item.indexOf(msg) !== -1) {\n      push = false;\n    }\n  }\n  if (push) {\n    this._queue.push(msg);\n    if (!this._timeout) {\n      this._setupInterval();\n    }\n  }\n};\n\n// Set up DataChannel handlers.\nReliable.prototype._setupDC = function() {\n  // Handle various message types.\n  var self = this;\n  this._dc.onmessage = function(e) {\n    var msg = e.data;\n    var datatype = msg.constructor;\n    // FIXME: msg is String until binary is supported.\n    // Once that happens, this will have to be smarter.\n    if (datatype === String) {\n      var ab = util.binaryStringToArrayBuffer(msg);\n      msg = util.unpack(ab);\n      self._handleMessage(msg);\n    }\n  };\n};\n\n// Handles an incoming message.\nReliable.prototype._handleMessage = function(msg) {\n  var id = msg[1];\n  var idata = this._incoming[id];\n  var odata = this._outgoing[id];\n  var data;\n  switch (msg[0]) {\n    // No chunking was done.\n    case 'no':\n      var message = id;\n      if (!!message) {\n        this.onmessage(util.unpack(message));\n      }\n      break;\n    // Reached the end of the message.\n    case 'end':\n      data = idata;\n\n      // In case end comes first.\n      this._received[id] = msg[2];\n\n      if (!data) {\n        break;\n      }\n\n      this._ack(id);\n      break;\n    case 'ack':\n      data = odata;\n      if (!!data) {\n        var ack = msg[2];\n        // Take the larger ACK, for out of order messages.\n        data.ack = Math.max(ack, data.ack);\n\n        // Clean up when all chunks are ACKed.\n        if (data.ack >= data.chunks.length) {\n          util.log('Time: ', new Date() - data.timer);\n          delete this._outgoing[id];\n        } else {\n          this._processAcks();\n        }\n      }\n      // If !data, just ignore.\n      break;\n    // Received a chunk of data.\n    case 'chunk':\n      // Create a new entry if none exists.\n      data = idata;\n      if (!data) {\n        var end = this._received[id];\n        if (end === true) {\n          break;\n        }\n        data = {\n          ack: ['ack', id, 0],\n          chunks: []\n        };\n        this._incoming[id] = data;\n      }\n\n      var n = msg[2];\n      var chunk = msg[3];\n      data.chunks[n] = new Uint8Array(chunk);\n\n      // If we get the chunk we're looking for, ACK for next missing.\n      // Otherwise, ACK the same N again.\n      if (n === data.ack[2]) {\n        this._calculateNextAck(id);\n      }\n      this._ack(id);\n      break;\n    default:\n      // Shouldn't happen, but would make sense for message to just go\n      // through as is.\n      this._handleSend(msg);\n      break;\n  }\n};\n\n// Chunks BL into smaller messages.\nReliable.prototype._chunk = function(bl) {\n  var chunks = [];\n  var size = bl.size;\n  var start = 0;\n  while (start < size) {\n    var end = Math.min(size, start + this._mtu);\n    var b = bl.slice(start, end);\n    var chunk = {\n      payload: b\n    }\n    chunks.push(chunk);\n    start = end;\n  }\n  util.log('Created', chunks.length, 'chunks.');\n  return chunks;\n};\n\n// Sends ACK N, expecting Nth blob chunk for message ID.\nReliable.prototype._ack = function(id) {\n  var ack = this._incoming[id].ack;\n\n  // if ack is the end value, then call _complete.\n  if (this._received[id] === ack[2]) {\n    this._complete(id);\n    this._received[id] = true;\n  }\n\n  this._handleSend(ack);\n};\n\n// Calculates the next ACK number, given chunks.\nReliable.prototype._calculateNextAck = function(id) {\n  var data = this._incoming[id];\n  var chunks = data.chunks;\n  for (var i = 0, ii = chunks.length; i < ii; i += 1) {\n    // This chunk is missing!!! Better ACK for it.\n    if (chunks[i] === undefined) {\n      data.ack[2] = i;\n      return;\n    }\n  }\n  data.ack[2] = chunks.length;\n};\n\n// Sends the next window of chunks.\nReliable.prototype._sendWindowedChunks = function(id) {\n  util.log('sendWindowedChunks for: ', id);\n  var data = this._outgoing[id];\n  var ch = data.chunks;\n  var chunks = [];\n  var limit = Math.min(data.ack + this._window, ch.length);\n  for (var i = data.ack; i < limit; i += 1) {\n    if (!ch[i].sent || i === data.ack) {\n      ch[i].sent = true;\n      chunks.push(['chunk', id, i, ch[i].payload]);\n    }\n  }\n  if (data.ack + this._window >= ch.length) {\n    chunks.push(['end', id, ch.length])\n  }\n  chunks._multiple = true;\n  this._handleSend(chunks);\n};\n\n// Puts together a message from chunks.\nReliable.prototype._complete = function(id) {\n  util.log('Completed called for', id);\n  var self = this;\n  var chunks = this._incoming[id].chunks;\n  var bl = new Blob(chunks);\n  util.blobToArrayBuffer(bl, function(ab) {\n    self.onmessage(util.unpack(ab));\n  });\n  delete this._incoming[id];\n};\n\n// Ups bandwidth limit on SDP. Meant to be called during offer/answer.\nReliable.higherBandwidthSDP = function(sdp) {\n  // AS stands for Application-Specific Maximum.\n  // Bandwidth number is in kilobits / sec.\n  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt\n\n  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their\n  // way.\n  var version = navigator.appVersion.match(/Chrome\\/(.*?) /);\n  if (version) {\n    version = parseInt(version[1].split('.').shift());\n    if (version < 31) {\n      var parts = sdp.split('b=AS:30');\n      var replace = 'b=AS:102400'; // 100 Mbps\n      if (parts.length > 1) {\n        return parts[0] + replace + parts[1];\n      }\n    }\n  }\n\n  return sdp;\n};\n\n// Overwritten, typically.\nReliable.prototype.onmessage = function(msg) {};\n\nmodule.exports.Reliable = Reliable;\n\n},{\"./util\":13}],13:[function(require,module,exports){\nvar BinaryPack = require('js-binarypack');\n\nvar util = {\n  debug: false,\n  \n  inherits: function(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  },\n  extend: function(dest, source) {\n    for(var key in source) {\n      if(source.hasOwnProperty(key)) {\n        dest[key] = source[key];\n      }\n    }\n    return dest;\n  },\n  pack: BinaryPack.pack,\n  unpack: BinaryPack.unpack,\n  \n  log: function () {\n    if (util.debug) {\n      var copy = [];\n      for (var i = 0; i < arguments.length; i++) {\n        copy[i] = arguments[i];\n      }\n      copy.unshift('Reliable: ');\n      console.log.apply(console, copy);\n    }\n  },\n\n  setZeroTimeout: (function(global) {\n    var timeouts = [];\n    var messageName = 'zero-timeout-message';\n\n    // Like setTimeout, but only takes a function argument.\t There's\n    // no time argument (always zero) and no arguments (you have to\n    // use a closure).\n    function setZeroTimeoutPostMessage(fn) {\n      timeouts.push(fn);\n      global.postMessage(messageName, '*');\n    }\t\t\n\n    function handleMessage(event) {\n      if (event.source == global && event.data == messageName) {\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        }\n        if (timeouts.length) {\n          timeouts.shift()();\n        }\n      }\n    }\n    if (global.addEventListener) {\n      global.addEventListener('message', handleMessage, true);\n    } else if (global.attachEvent) {\n      global.attachEvent('onmessage', handleMessage);\n    }\n    return setZeroTimeoutPostMessage;\n  }(this)),\n  \n  blobToArrayBuffer: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsArrayBuffer(blob);\n  },\n  blobToBinaryString: function(blob, cb){\n    var fr = new FileReader();\n    fr.onload = function(evt) {\n      cb(evt.target.result);\n    };\n    fr.readAsBinaryString(blob);\n  },\n  binaryStringToArrayBuffer: function(binary) {\n    var byteArray = new Uint8Array(binary.length);\n    for (var i = 0; i < binary.length; i++) {\n      byteArray[i] = binary.charCodeAt(i) & 0xff;\n    }\n    return byteArray.buffer;\n  },\n  randomToken: function () {\n    return Math.random().toString(36).substr(2);\n  }\n};\n\nmodule.exports = util;\n\n},{\"js-binarypack\":10}]},{},[3]);\n\n\n//# sourceURL=webpack:///../libs/peer.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ../libs/peer.js */ \"../libs/peer.js\");\nconst CONSTANTS = __webpack_require__(/*! ../libs/constants.js */ \"../libs/constants.js\");\nconst Infos = __webpack_require__(/*! ../libs/infos.js */ \"../libs/infos.js\");\n\nconsole.log(\"Client source hit.\");\n\nvar lastPeerId = 0;\nvar peer;\nvar conn;\n\nvar recvIdInput = {\n    value: \"mnr6qkd369f00000\"\n};\n\nlet globalMatchInfo = Infos.GlobalMatchInfo();\nlet globalRoundInfo = Infos.GlobalRoundInfo();\nlet playerMatchInfo = Infos.PlayerMatchInfo();\nlet playerRoundInfo = Infos.PlayerRoundInfo();\n\nupdateAllInfo();\n\nvar sendTestMessageButton = document.getElementById(\"testButton\");\nsendTestMessageButton.onclick = () => conn.send(\"test\");\n\nvar setHostId = document.getElementById(\"setHostId\");\nvar submitHostId = document.getElementById(\"submitHostId\");\nsubmitHostId.onclick = () => {\n    recvIdInput.value = setHostId.value;\n    initialize();\n    join();\n}\n\n\n\nfunction initialize() {\n    // Create own peer object with connection to shared PeerJS server\n    peer = new Peer('', {\n        host: location.hostname,\n        port: location.port || (location.protocol === 'https:' ? 443 : 80),\n        path: '/peerjs',\n        debug: 3\n    });\n\n    peer.on('open', function (id) {\n        // Workaround for peer.reconnect deleting previous id\n        if (peer.id === null) {\n            console.log('Received null id from peer open');\n            peer.id = lastPeerId;\n        } else {\n            lastPeerId = peer.id;\n        }\n\n        console.log('ID: ' + peer.id);\n    });\n    peer.on('disconnected', function () {\n        console.log('Connection lost. Please reconnect');\n\n        // Workaround for peer.reconnect deleting previous id\n        peer.id = lastPeerId;\n        peer._lastServerId = lastPeerId;\n        peer.reconnect();\n    });\n    peer.on('close', function() {\n        conn = null;\n        console.log('Connection destroyed');\n    });\n    peer.on('error', function (err) {\n        console.log(err);\n        alert('' + err);\n    });\n};\n\n/**\n * Create the connection between the two Peers.\n *\n * Sets up callbacks that handle any events related to the\n * connection and data received on it.\n */\nfunction join() {\n    // Close old connection\n    if (conn) {\n        conn.close();\n    }\n\n    // Create connection to destination peer specified in the input field\n    conn = peer.connect(recvIdInput.value, {\n        reliable: true\n    });\n\n    conn.on('open', function () {\n        console.log(\"Connected to: \" + conn.peer);\n\n        conn.send(\"test\");\n        globalMatchInfo.matchState = \"AWAITING_PLAYERS\";\n        updateGlobalMatchInfo();\n    });\n    // Handle incoming data (messages only since this is the signal sender)\n    conn.on('data', function (data) {\n        console.log(data);\n        recieveData(data);\n    });\n    conn.on('close', function () {\n        console.log(\"Connection closed\");\n    });\n\n\n    let playRedButton = document.getElementById(\"playRedCard\");\n    playRedButton.onclick = () => {\n        conn.send(\n            {\n                action: CONSTANTS.PLAY_RED_CARD\n            }\n        );\n    }\n\n    let playBlackButton = document.getElementById(\"playBlackCard\");\n    playBlackButton.onclick = () => {\n        conn.send(\n            {\n                action: CONSTANTS.PLAY_BLACK_CARD\n            }\n        );\n    }\n\n    let challengeAmountInput = document.getElementById(\"challengeAmount\");\n    let makeChallengeButton = document.getElementById(\"makeChallenge\");\n    makeChallengeButton.onclick = () => {\n        conn.send(\n            {\n                action: CONSTANTS.CHALLENGE,\n                payload: {\n                    challengeBid: challengeAmountInput.value\n                }\n            }\n        );\n    }\n\n    let passButton = document.getElementById(\"pass\");\n    passButton.onclick = () => {\n        conn.send(\n            {\n                action: CONSTANTS.PASS\n            }\n        );\n    }\n};\n\nfunction recieveData(data) {\n    console.log(\"Received data from host:\")\n    console.log(data);\n    switch(data.action) {\n        case CONSTANTS.SET_GLOBAL_MATCH_INFO:\n            globalMatchInfo = data.payload;\n            updateGlobalMatchInfo();\n            console.log(data.payload, \"Setting globalMatchInfo\");\n            break;\n        case CONSTANTS.SET_GLOBAL_ROUND_INFO:\n            globalRoundInfo = data.payload;\n            updateGlobalRoundInfo();\n            console.log(data.payload, \"Setting globalRoundInfo\");\n            break;\n        case CONSTANTS.SET_PLAYER_MATCH_INFO:\n            playerMatchInfo = data.payload;\n            updatePlayerMatchInfo();\n            break;\n        case CONSTANTS.SET_PLAYER_ROUND_INFO:\n            playerRoundInfo = data.payload;\n            updatePlayerRoundInfo();\n            break;\n        case CONSTANTS.SET_ALL_INFO:\n            globalMatchInfo = data.payload.globalMatchInfo;\n            globalRoundInfo = data.payload.globalRoundInfo;\n            playerMatchInfo = data.payload.playerMatchInfo;\n            playerRoundInfo = data.payload.playerRoundInfo;\n            updateAllInfo();\n            break;\n\n    }\n}\n\nfunction updateAllInfo() {\n    updateGlobalMatchInfo();\n    updateGlobalRoundInfo();\n    updatePlayerMatchInfo();\n    updatePlayerRoundInfo();\n}\n\nfunction updateGlobalMatchInfo() {\n    let gameStateDisplay = document.getElementById(\"gameState\");\n    gameStateDisplay.innerText = globalMatchInfo.matchState;\n}\n\nfunction updateGlobalRoundInfo() {\n    let activePlayer = document.getElementById(\"activePlayer\");\n    if (globalRoundInfo.activePlayer === CONSTANTS.ALL_ACTIVE) {\n        activePlayer.innerText = \"All players active\";\n    } else if (globalRoundInfo.activePlayer === playerRoundInfo.peerId) {\n        activePlayer.innerText = \"You are the active player: \" + playerRoundInfo.peerId;\n    } else {\n        activePlayer.innerText = \"Waiting for active player: \" + globalRoundInfo.activePlayer;\n    }\n\n    let roundState = document.getElementById(\"roundState\");\n    roundState.innerText = globalRoundInfo.roundState\n\n    let currentChallengeBid = document.getElementById(\"currentChallengeBid\");\n    currentChallengeBid.innerText = globalRoundInfo.currentChallengeBid;\n\n    let successfulReveals = document.getElementById(\"successfulReveals\");\n    successfulReveals.innerText = globalRoundInfo.successfulReveals;\n\n    drawOtherPlayersCards();\n}\n\nfunction updatePlayerMatchInfo() {\n    let wins = document.getElementById(\"wins\");\n    wins.innerText = playerMatchInfo.wins;\n\n    let peerIdFromHost = document.getElementById(\"peerIdFromHost\");\n    peerIdFromHost.innerText = playerMatchInfo.peerId\n}\n\nfunction updatePlayerRoundInfo() {\n    let handRedCards = document.getElementById(\"handRedCards\");\n    handRedCards.innerText = playerRoundInfo.handRedCards;\n\n    let handBlackCards = document.getElementById(\"handBlackCards\");\n    handBlackCards.innerText = playerRoundInfo.handBlackCards;\n\n    drawStack();\n}\n\nfunction drawStack() {\n    let stackList = document.getElementById(\"stackList\");\n\n    while (stackList.firstChild) {\n        stackList.removeChild(stackList.firstChild);\n    }\n\n    playerRoundInfo.stack.forEach(\n        card => {\n            let cardItem = document.createElement('li');\n            cardItem.appendChild(document.createTextNode(card));\n            stackList.appendChild(cardItem);\n        }\n    )\n}\n\nfunction drawOtherPlayersCards() {\n    let otherPlayersCards = document.getElementById(\"otherPlayersCards\");\n\n    while (otherPlayersCards.firstChild) {\n        otherPlayersCards.removeChild(otherPlayersCards.firstChild);\n    }\n\n    Object.keys(globalRoundInfo.stackSizeByPlayer).forEach(function(key) {\n        let otherPlayerCardsItem = document.createElement('li');\n        let text = \"Player: \" + key + \" card count: \" + globalRoundInfo.stackSizeByPlayer[key];\n        otherPlayerCardsItem.appendChild(document.createTextNode(text));\n        otherPlayersCards.appendChild(otherPlayerCardsItem);\n\n        let revealCardButtonItem = document.createElement('BUTTON');\n        let buttonTextNode = document.createTextNode(\"Reveal Card from player: \" + key);\n        revealCardButtonItem.appendChild(buttonTextNode);\n\n        revealCardButtonItem.onclick = () => {\n            conn.send(\n                {\n                    action: CONSTANTS.REVEAL,\n                    payload: {\n                        revealPlayer: key\n                    }\n                }\n            );\n        }\n\n        otherPlayerCardsItem.appendChild(revealCardButtonItem);\n      })\n}\n\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

/******/ });